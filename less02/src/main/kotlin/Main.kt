/*
За основу берём код решения домашнего задания из предыдущего семинара и дорабатываем его.

— Создайте иерархию sealed классов, которые представляют собой команды.
В корне иерархии интерфейс Command.

— В каждом классе иерархии должна быть функция isValid():Boolean,
которая возвращает true, если команда введена с корректными аргументами.
Проверку телефона и email нужно перенести в эту функцию.

— Напишите функцию readCommand():Command,
которая читает команду из текстового ввода, распознаёт её и возвращает один из классов-наследников Command,
соответствующий введённой команде.

— Создайте data класс Person, который представляет собой запись о человеке.
Этот класс должен содержать поля:
name – имя человека
phone – номер телефона
email – адрес электронной почты

— Добавьте новую команду show, которая выводит последнее значение, введённой с помощью команды add.
Для этого значение должно быть сохранено в переменную типа Person.
Если на момент выполнения команды show не было ничего введено, нужно вывести на экран сообщение “Not initialized”.

— Функция main должна выглядеть следующем образом.
Для каждой команды от пользователя:
Читаем команду с помощью функции readCommand
Выводим на экран получившийся экземпляр Command
Если isValid для команды возвращает false, выводим help. Если true, обрабатываем команду внутри when.
 */

// вынес в "глобальные" переменные, чтобы не создавать объекты классов каждый раз при выполнении цикла while(true)
//var show: Show = Show() // здесь однозначно "глобальная", чтоб можно было использовать в классе Add при записи последних введенных данных
//var help: Help = Help()
//var exit: Exit = Exit()
//var add: Add = Add()

/*
Суть классов-команд как раз в том, что они могут хранить в себе состояние - введённые в них данные, и потом их обрабатывать.
В виде класса команды мы связываем логику с данными для этой команды.
Поэтому их надо создавать как раз таки на итерациях цикла while.
Если с командой не связаны данные, например Exit и Help, её можно объявить как object,
и у этой команды всегда будет только один экземпляр.
Класс Person должен содержать только данные о человеке без какого либо знания об окружении и его состоянии.
Вообще в идеале каждый класс должен выполнять свою узконаправленную задачу и быть минимально связан с остальными классами.
Глобальные var переменные в файле Main.kt, доступные отовсюду, это, к сожалению, то, что Котлин позволяет делать,
но неправильно с точки зрения архитектуры.
 */
fun main() {
    while(true) {
        val mainMenu = "Введите команду (add, help, show, exit): "
        val command = readCommand(InputData.inputChoice(mainMenu))
        command.runCommand()

        when (command) {
            is Exit -> {
                println("Работа приложения завершена\n")
                return
            }
            is Add -> command.inputPersonData()
            is Help -> command.printHelp()
            is Show -> println(command.printLastData())
        }
    }
}


fun readCommand(input : String): Command {
    val command: Command
    when (input.lowercase()) {
        "exit" -> command = Exit
        "help" -> command = Help
        "add" -> command = Add()
        "show" -> command = Show
        else -> {
            println("НЕКОРРЕКТНАЯ КОМАНДА. Повторите ввод (help - в помощь):")
            command = Help
        }
    }
    return command
}


